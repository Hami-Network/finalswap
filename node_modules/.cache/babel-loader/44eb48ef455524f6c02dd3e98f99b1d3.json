{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints';\nimport { ethers } from 'ethers';\nimport { BetPosition, PredictionStatus } from 'state/types';\nimport { multicallv2 } from 'utils/multicall';\nimport predictionsAbi from 'config/abi/predictions.json';\nimport { getPredictionsAddress } from 'utils/addressHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nexport let Result;\n\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\n\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\nexport const transformUserResponse = userResponse => {\n  const {\n    id,\n    createdAt,\n    updatedAt,\n    block,\n    totalBets,\n    totalBetsBull,\n    totalBetsBear,\n    totalBNB,\n    totalBNBBull,\n    totalBNBBear,\n    totalBetsClaimed,\n    totalBNBClaimed,\n    winRate,\n    averageBNB,\n    netBNB\n  } = userResponse;\n  return {\n    id,\n    createdAt: numberOrNull(createdAt),\n    updatedAt: numberOrNull(updatedAt),\n    block: numberOrNull(block),\n    totalBets: numberOrNull(totalBets),\n    totalBetsBull: numberOrNull(totalBetsBull),\n    totalBetsBear: numberOrNull(totalBetsBear),\n    totalBNB: totalBNB ? parseFloat(totalBNB) : 0,\n    totalBNBBull: totalBNBBull ? parseFloat(totalBNBBull) : 0,\n    totalBNBBear: totalBNBBear ? parseFloat(totalBNBBear) : 0,\n    totalBetsClaimed: numberOrNull(totalBetsClaimed),\n    totalBNBClaimed: totalBNBClaimed ? parseFloat(totalBNBClaimed) : 0,\n    winRate: winRate ? parseFloat(winRate) : 0,\n    averageBNB: averageBNB ? parseFloat(averageBNB) : 0,\n    netBNB: netBNB ? parseFloat(netBNB) : 0\n  };\n};\n\nconst getRoundPosition = positionResponse => {\n  if (positionResponse === 'Bull') {\n    return BetPosition.BULL;\n  }\n\n  if (positionResponse === 'Bear') {\n    return BetPosition.BEAR;\n  }\n\n  return null;\n};\n\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    block: numberOrNull(betResponse.block),\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedAt: numberOrNull(betResponse.claimedAt),\n    claimedBlock: numberOrNull(betResponse.claimedBlock),\n    claimedHash: betResponse.claimedHash,\n    claimedBNB: betResponse.claimedBNB ? parseFloat(betResponse.claimedBNB) : 0,\n    claimedNetBNB: betResponse.claimedNetBNB ? parseFloat(betResponse.claimedNetBNB) : 0,\n    createdAt: numberOrNull(betResponse.createdAt),\n    updatedAt: numberOrNull(betResponse.updatedAt)\n  };\n\n  if (betResponse.user) {\n    bet.user = transformUserResponse(betResponse.user);\n  }\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n\n  return bet;\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    position,\n    startAt,\n    startBlock,\n    startHash,\n    lockAt,\n    lockBlock,\n    lockHash,\n    lockPrice,\n    lockRoundId,\n    closeAt,\n    closeBlock,\n    closeHash,\n    closePrice,\n    closeRoundId,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bullAmount,\n    bearBets,\n    bearAmount,\n    bets = []\n  } = roundResponse;\n  return {\n    id,\n    failed,\n    startHash,\n    lockHash,\n    lockRoundId,\n    closeRoundId,\n    closeHash,\n    position: getRoundPosition(position),\n    epoch: numberOrNull(epoch),\n    startAt: numberOrNull(startAt),\n    startBlock: numberOrNull(startBlock),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : 0,\n    closeAt: numberOrNull(closeAt),\n    closeBlock: numberOrNull(closeBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : 0,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bullAmount: bullAmount ? parseFloat(bullAmount) : 0,\n    bearBets: numberOrNull(bearBets),\n    bearAmount: bearAmount ? parseFloat(bearAmount) : 0,\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\n\nexport const getCanClaim = bet => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n};\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\n\nexport const getUnclaimedWinningBets = bets => {\n  return bets.filter(getCanClaim);\n};\nexport const getTotalWon = async () => {\n  const {\n    market\n  } = await request(GRAPH_API_PREDICTION, gql`\n      query getTotalWonData {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n      }\n    `);\n  const totalBNB = market.totalBNB ? parseFloat(market.totalBNB) : 0;\n  const totalBNBTreasury = market.totalBNBTreasury ? parseFloat(market.totalBNBTreasury) : 0;\n  return Math.max(totalBNB - totalBNBTreasury, 0);\n};\nexport const getBetHistory = async (where = {}, first = 1000, skip = 0) => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n}; // V2 REFACTOR\n\nexport const getLedgerData = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const ledgerCalls = epochs.map(epoch => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account]\n  }));\n  const response = await multicallv2(predictionsAbi, ledgerCalls);\n  return response;\n};\nexport const getClaimStatuses = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const claimableCalls = epochs.map(epoch => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account]\n  }));\n  const claimableResponses = await multicallv2(predictionsAbi, claimableCalls); // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\n  // This can be removed in Predictions V2\n\n  const ledgerResponses = await getLedgerData(account, epochs);\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const {\n      amount,\n      claimed\n    } = ledgerResponses[index];\n    const epoch = epochs[index];\n    const [claimable] = claimableResponse;\n    return { ...accum,\n      [epoch]: claimable && amount.gt(0) && !claimed\n    };\n  }, {});\n};\nexport const getPredictionData = async () => {\n  const address = getPredictionsAddress();\n  const staticCalls = ['currentEpoch', 'intervalSeconds', 'minBetAmount', 'paused', 'bufferSeconds'].map(method => ({\n    address,\n    name: method\n  }));\n  const [[currentEpoch], [intervalSeconds], [minBetAmount], [paused], [bufferSeconds]] = await multicallv2(predictionsAbi, staticCalls);\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalSeconds: intervalSeconds.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    bufferSeconds: bufferSeconds.toNumber()\n  };\n};\nexport const getRoundsData = async epochs => {\n  const address = getPredictionsAddress();\n  const calls = epochs.map(epoch => ({\n    address,\n    name: 'rounds',\n    params: [epoch]\n  }));\n  const response = await multicallv2(predictionsAbi, calls);\n  return response;\n};\nexport const makeFutureRoundResponse = (epoch, startTimestamp) => {\n  return {\n    epoch,\n    startTimestamp,\n    lockTimestamp: null,\n    closeTimestamp: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false,\n    lockOracleId: null,\n    closeOracleId: null\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return { ...accum,\n      [round.epoch.toString()]: round\n    };\n  }, {});\n};\nexport const serializePredictionsLedgerResponse = ledgerResponse => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed\n});\nexport const makeLedgerData = (account, ledgers, epochs) => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum;\n    } // If the amount is zero that means the user did not bet\n\n\n    if (ledgerResponse.amount.eq(0)) {\n      return accum;\n    }\n\n    const epoch = epochs[index].toString();\n    return { ...accum,\n      [account]: { ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse)\n      }\n    };\n  }, {});\n};\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\n\nexport const serializePredictionsRoundsResponse = response => {\n  const {\n    epoch,\n    startTimestamp,\n    lockTimestamp,\n    closeTimestamp,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardBaseCalAmount,\n    rewardAmount,\n    oracleCalled,\n    lockOracleId,\n    closeOracleId\n  } = response;\n  return {\n    oracleCalled,\n    epoch: epoch.toNumber(),\n    startTimestamp: startTimestamp.eq(0) ? null : startTimestamp.toNumber(),\n    lockTimestamp: lockTimestamp.eq(0) ? null : lockTimestamp.toNumber(),\n    closeTimestamp: closeTimestamp.eq(0) ? null : closeTimestamp.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    lockOracleId: lockOracleId.toString(),\n    closeOracleId: closeOracleId.toString()\n  };\n};\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\n\nexport const parseBigNumberObj = data => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key];\n\n    if (value && (value === null || value === void 0 ? void 0 : value.type) === 'BigNumber') {\n      return { ...accum,\n        [key]: ethers.BigNumber.from(value)\n      };\n    }\n\n    return { ...accum,\n      [key]: value\n    };\n  }, {});\n};","map":{"version":3,"sources":["C:/Users/97154/swap/hami/LokiswapUI/src/state/predictions/helpers.ts"],"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","multicallv2","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","transformUserResponse","userResponse","id","createdAt","updatedAt","block","totalBets","totalBetsBull","totalBetsBear","totalBNB","totalBNBBull","totalBNBBear","totalBetsClaimed","totalBNBClaimed","winRate","averageBNB","netBNB","parseFloat","getRoundPosition","positionResponse","BULL","BEAR","transformBetResponse","betResponse","bet","hash","amount","position","claimed","claimedAt","claimedBlock","claimedHash","claimedBNB","claimedNetBNB","user","round","transformRoundResponse","roundResponse","epoch","failed","startAt","startBlock","startHash","lockAt","lockBlock","lockHash","lockPrice","lockRoundId","closeAt","closeBlock","closeHash","closePrice","closeRoundId","totalAmount","bullBets","bullAmount","bearBets","bearAmount","bets","map","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getTotalWon","market","totalBNBTreasury","Math","max","getBetHistory","where","first","skip","response","getBet","betId","toLowerCase","getLedgerData","account","epochs","address","ledgerCalls","name","params","getClaimStatuses","claimableCalls","claimableResponses","ledgerResponses","reduce","accum","claimableResponse","index","claimable","gt","getPredictionData","staticCalls","method","intervalSeconds","minBetAmount","paused","bufferSeconds","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","startTimestamp","lockTimestamp","closeTimestamp","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","lockOracleId","closeOracleId","makeRoundData","rounds","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\r\nimport { ethers } from 'ethers'\r\nimport {\r\n  Bet,\r\n  LedgerData,\r\n  BetPosition,\r\n  PredictionsState,\r\n  PredictionStatus,\r\n  ReduxNodeLedger,\r\n  ReduxNodeRound,\r\n  Round,\r\n  RoundData,\r\n  PredictionUser,\r\n} from 'state/types'\r\nimport { multicallv2 } from 'utils/multicall'\r\nimport predictionsAbi from 'config/abi/predictions.json'\r\nimport { getPredictionsAddress } from 'utils/addressHelpers'\r\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\r\nimport {\r\n  BetResponse,\r\n  getRoundBaseFields,\r\n  getBetBaseFields,\r\n  getUserBaseFields,\r\n  RoundResponse,\r\n  TotalWonMarketResponse,\r\n  UserResponse,\r\n} from './queries'\r\n\r\nexport enum Result {\r\n  WIN = 'win',\r\n  LOSE = 'lose',\r\n  CANCELED = 'canceled',\r\n  LIVE = 'live',\r\n}\r\n\r\nexport const numberOrNull = (value: string) => {\r\n  if (value === null) {\r\n    return null\r\n  }\r\n\r\n  const valueNum = Number(value)\r\n  return Number.isNaN(valueNum) ? null : valueNum\r\n}\r\n\r\nexport const transformUserResponse = (userResponse: UserResponse): PredictionUser => {\r\n  const {\r\n    id,\r\n    createdAt,\r\n    updatedAt,\r\n    block,\r\n    totalBets,\r\n    totalBetsBull,\r\n    totalBetsBear,\r\n    totalBNB,\r\n    totalBNBBull,\r\n    totalBNBBear,\r\n    totalBetsClaimed,\r\n    totalBNBClaimed,\r\n    winRate,\r\n    averageBNB,\r\n    netBNB,\r\n  } = userResponse\r\n\r\n  return {\r\n    id,\r\n    createdAt: numberOrNull(createdAt),\r\n    updatedAt: numberOrNull(updatedAt),\r\n    block: numberOrNull(block),\r\n    totalBets: numberOrNull(totalBets),\r\n    totalBetsBull: numberOrNull(totalBetsBull),\r\n    totalBetsBear: numberOrNull(totalBetsBear),\r\n    totalBNB: totalBNB ? parseFloat(totalBNB) : 0,\r\n    totalBNBBull: totalBNBBull ? parseFloat(totalBNBBull) : 0,\r\n    totalBNBBear: totalBNBBear ? parseFloat(totalBNBBear) : 0,\r\n    totalBetsClaimed: numberOrNull(totalBetsClaimed),\r\n    totalBNBClaimed: totalBNBClaimed ? parseFloat(totalBNBClaimed) : 0,\r\n    winRate: winRate ? parseFloat(winRate) : 0,\r\n    averageBNB: averageBNB ? parseFloat(averageBNB) : 0,\r\n    netBNB: netBNB ? parseFloat(netBNB) : 0,\r\n  }\r\n}\r\n\r\nconst getRoundPosition = (positionResponse: string) => {\r\n  if (positionResponse === 'Bull') {\r\n    return BetPosition.BULL\r\n  }\r\n\r\n  if (positionResponse === 'Bear') {\r\n    return BetPosition.BEAR\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\r\n  const bet = {\r\n    id: betResponse.id,\r\n    hash: betResponse.hash,\r\n    block: numberOrNull(betResponse.block),\r\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\r\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\r\n    claimed: betResponse.claimed,\r\n    claimedAt: numberOrNull(betResponse.claimedAt),\r\n    claimedBlock: numberOrNull(betResponse.claimedBlock),\r\n    claimedHash: betResponse.claimedHash,\r\n    claimedBNB: betResponse.claimedBNB ? parseFloat(betResponse.claimedBNB) : 0,\r\n    claimedNetBNB: betResponse.claimedNetBNB ? parseFloat(betResponse.claimedNetBNB) : 0,\r\n    createdAt: numberOrNull(betResponse.createdAt),\r\n    updatedAt: numberOrNull(betResponse.updatedAt),\r\n  } as Bet\r\n\r\n  if (betResponse.user) {\r\n    bet.user = transformUserResponse(betResponse.user)\r\n  }\r\n\r\n  if (betResponse.round) {\r\n    bet.round = transformRoundResponse(betResponse.round)\r\n  }\r\n\r\n  return bet\r\n}\r\n\r\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\r\n  const {\r\n    id,\r\n    epoch,\r\n    failed,\r\n    position,\r\n    startAt,\r\n    startBlock,\r\n    startHash,\r\n    lockAt,\r\n    lockBlock,\r\n    lockHash,\r\n    lockPrice,\r\n    lockRoundId,\r\n    closeAt,\r\n    closeBlock,\r\n    closeHash,\r\n    closePrice,\r\n    closeRoundId,\r\n    totalBets,\r\n    totalAmount,\r\n    bullBets,\r\n    bullAmount,\r\n    bearBets,\r\n    bearAmount,\r\n    bets = [],\r\n  } = roundResponse\r\n\r\n  return {\r\n    id,\r\n    failed,\r\n    startHash,\r\n    lockHash,\r\n    lockRoundId,\r\n    closeRoundId,\r\n    closeHash,\r\n    position: getRoundPosition(position),\r\n    epoch: numberOrNull(epoch),\r\n    startAt: numberOrNull(startAt),\r\n    startBlock: numberOrNull(startBlock),\r\n    lockAt: numberOrNull(lockAt),\r\n    lockBlock: numberOrNull(lockBlock),\r\n    lockPrice: lockPrice ? parseFloat(lockPrice) : 0,\r\n    closeAt: numberOrNull(closeAt),\r\n    closeBlock: numberOrNull(closeBlock),\r\n    closePrice: closePrice ? parseFloat(closePrice) : 0,\r\n    totalBets: numberOrNull(totalBets),\r\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\r\n    bullBets: numberOrNull(bullBets),\r\n    bullAmount: bullAmount ? parseFloat(bullAmount) : 0,\r\n    bearBets: numberOrNull(bearBets),\r\n    bearAmount: bearAmount ? parseFloat(bearAmount) : 0,\r\n    bets: bets.map(transformBetResponse),\r\n  }\r\n}\r\n\r\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\r\n  const { round } = bet\r\n  if (round.failed) {\r\n    return Result.CANCELED\r\n  }\r\n\r\n  if (round.epoch >= currentEpoch - 1) {\r\n    return Result.LIVE\r\n  }\r\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\r\n\r\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\r\n}\r\n\r\n/**\r\n * Given a bet object, check if it is eligible to be claimed or refunded\r\n */\r\nexport const getCanClaim = (bet: Bet) => {\r\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\r\n}\r\n\r\n/**\r\n * Returns only bets where the user has won.\r\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\r\n */\r\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\r\n  return bets.filter(getCanClaim)\r\n}\r\n\r\nexport const getTotalWon = async (): Promise<number> => {\r\n  const { market } = (await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getTotalWonData {\r\n        market(id: 1) {\r\n          totalBNB\r\n          totalBNBTreasury\r\n        }\r\n      }\r\n    `,\r\n  )) as { market: TotalWonMarketResponse }\r\n\r\n  const totalBNB = market.totalBNB ? parseFloat(market.totalBNB) : 0\r\n  const totalBNBTreasury = market.totalBNBTreasury ? parseFloat(market.totalBNBTreasury) : 0\r\n\r\n  return Math.max(totalBNB - totalBNBTreasury, 0)\r\n}\r\n\r\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\r\n\r\nexport const getBetHistory = async (\r\n  where: BetHistoryWhereClause = {},\r\n  first = 1000,\r\n  skip = 0,\r\n): Promise<BetResponse[]> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\r\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n    `,\r\n    { first, skip, where },\r\n  )\r\n  return response.bets\r\n}\r\n\r\nexport const getBet = async (betId: string): Promise<BetResponse> => {\r\n  const response = await request(\r\n    GRAPH_API_PREDICTION,\r\n    gql`\r\n      query getBet($id: ID!) {\r\n        bet(id: $id) {\r\n          ${getBetBaseFields()}\r\n          round {\r\n            ${getRoundBaseFields()}\r\n          }\r\n          user {\r\n            ${getUserBaseFields()}\r\n          } \r\n        }\r\n      }\r\n  `,\r\n    {\r\n      id: betId.toLowerCase(),\r\n    },\r\n  )\r\n  return response.bet\r\n}\r\n\r\n// V2 REFACTOR\r\nexport const getLedgerData = async (account: string, epochs: number[]) => {\r\n  const address = getPredictionsAddress()\r\n  const ledgerCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'ledger',\r\n    params: [epoch, account],\r\n  }))\r\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\r\n  return response\r\n}\r\n\r\nexport const getClaimStatuses = async (\r\n  account: string,\r\n  epochs: number[],\r\n): Promise<PredictionsState['claimableStatuses']> => {\r\n  const address = getPredictionsAddress()\r\n  const claimableCalls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'claimable',\r\n    params: [epoch, account],\r\n  }))\r\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\r\n\r\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\r\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\r\n  // This can be removed in Predictions V2\r\n  const ledgerResponses = await getLedgerData(account, epochs)\r\n\r\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\r\n    const { amount, claimed } = ledgerResponses[index]\r\n    const epoch = epochs[index]\r\n    const [claimable] = claimableResponse\r\n\r\n    return {\r\n      ...accum,\r\n      [epoch]: claimable && amount.gt(0) && !claimed,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport type MarketData = Pick<\r\n  PredictionsState,\r\n  'status' | 'currentEpoch' | 'intervalSeconds' | 'minBetAmount' | 'bufferSeconds'\r\n>\r\nexport const getPredictionData = async (): Promise<MarketData> => {\r\n  const address = getPredictionsAddress()\r\n  const staticCalls = ['currentEpoch', 'intervalSeconds', 'minBetAmount', 'paused', 'bufferSeconds'].map((method) => ({\r\n    address,\r\n    name: method,\r\n  }))\r\n  const [[currentEpoch], [intervalSeconds], [minBetAmount], [paused], [bufferSeconds]] = await multicallv2(\r\n    predictionsAbi,\r\n    staticCalls,\r\n  )\r\n\r\n  return {\r\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\r\n    currentEpoch: currentEpoch.toNumber(),\r\n    intervalSeconds: intervalSeconds.toNumber(),\r\n    minBetAmount: minBetAmount.toString(),\r\n    bufferSeconds: bufferSeconds.toNumber(),\r\n  }\r\n}\r\n\r\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\r\n  const address = getPredictionsAddress()\r\n  const calls = epochs.map((epoch) => ({\r\n    address,\r\n    name: 'rounds',\r\n    params: [epoch],\r\n  }))\r\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\r\n  return response\r\n}\r\n\r\nexport const makeFutureRoundResponse = (epoch: number, startTimestamp: number): ReduxNodeRound => {\r\n  return {\r\n    epoch,\r\n    startTimestamp,\r\n    lockTimestamp: null,\r\n    closeTimestamp: null,\r\n    lockPrice: null,\r\n    closePrice: null,\r\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\r\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\r\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\r\n    oracleCalled: false,\r\n    lockOracleId: null,\r\n    closeOracleId: null,\r\n  }\r\n}\r\n\r\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\r\n  return rounds.reduce((accum, round) => {\r\n    return {\r\n      ...accum,\r\n      [round.epoch.toString()]: round,\r\n    }\r\n  }, {})\r\n}\r\n\r\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\r\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\r\n  amount: ledgerResponse.amount.toJSON(),\r\n  claimed: ledgerResponse.claimed,\r\n})\r\n\r\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\r\n  return ledgers.reduce((accum, ledgerResponse, index) => {\r\n    if (!ledgerResponse) {\r\n      return accum\r\n    }\r\n\r\n    // If the amount is zero that means the user did not bet\r\n    if (ledgerResponse.amount.eq(0)) {\r\n      return accum\r\n    }\r\n\r\n    const epoch = epochs[index].toString()\r\n\r\n    return {\r\n      ...accum,\r\n      [account]: {\r\n        ...accum[account],\r\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\r\n      },\r\n    }\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Serializes the return from the \"rounds\" call for redux\r\n */\r\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\r\n  const {\r\n    epoch,\r\n    startTimestamp,\r\n    lockTimestamp,\r\n    closeTimestamp,\r\n    lockPrice,\r\n    closePrice,\r\n    totalAmount,\r\n    bullAmount,\r\n    bearAmount,\r\n    rewardBaseCalAmount,\r\n    rewardAmount,\r\n    oracleCalled,\r\n    lockOracleId,\r\n    closeOracleId,\r\n  } = response\r\n\r\n  return {\r\n    oracleCalled,\r\n    epoch: epoch.toNumber(),\r\n    startTimestamp: startTimestamp.eq(0) ? null : startTimestamp.toNumber(),\r\n    lockTimestamp: lockTimestamp.eq(0) ? null : lockTimestamp.toNumber(),\r\n    closeTimestamp: closeTimestamp.eq(0) ? null : closeTimestamp.toNumber(),\r\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\r\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\r\n    totalAmount: totalAmount.toJSON(),\r\n    bullAmount: bullAmount.toJSON(),\r\n    bearAmount: bearAmount.toJSON(),\r\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\r\n    rewardAmount: rewardAmount.toJSON(),\r\n    lockOracleId: lockOracleId.toString(),\r\n    closeOracleId: closeOracleId.toString(),\r\n  }\r\n}\r\n\r\n/**\r\n * Parse serialized values back into ethers.BigNumber\r\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\r\n */\r\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\r\n  return Object.keys(data).reduce((accum, key) => {\r\n    const value = data[key]\r\n\r\n    if (value && value?.type === 'BigNumber') {\r\n      return {\r\n        ...accum,\r\n        [key]: ethers.BigNumber.from(value),\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...accum,\r\n      [key]: value,\r\n    }\r\n  }, {}) as K\r\n}\r\n"]},"metadata":{},"sourceType":"module"}