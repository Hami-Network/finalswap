{"ast":null,"code":"import _objectSpread from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _taggedTemplateLiteral from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";import _asyncToGenerator from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";var _templateObject;import{request,gql}from'graphql-request';import{GRAPH_API_LOTTERY}from'config/constants/endpoints';import{getRoundIdsArray,fetchMultipleLotteries,hasRoundBeenClaimed}from'./helpers';import{fetchUserTicketsForMultipleRounds}from'./getUserTicketsData';var MAX_USER_LOTTERIES_REQUEST_SIZE=100;/* eslint-disable camelcase */var applyNodeDataToUserGraphResponse=function applyNodeDataToUserGraphResponse(userNodeData,userGraphData,lotteryNodeData){//   If no graph rounds response - return node data\nif(userGraphData.length===0){return lotteryNodeData.map(function(nodeRound){var ticketDataForRound=userNodeData.find(function(roundTickets){return roundTickets.roundId===nodeRound.lotteryId;});return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:\"\".concat(ticketDataForRound.userTickets.length.toString()),tickets:ticketDataForRound.userTickets};});}//   Else if there is a graph response - merge with node data where node data is more accurate\nvar mergedResponse=userGraphData.map(function(graphRound,index){var nodeRound=lotteryNodeData[index];// if there is node data for this index, overwrite graph data. Otherwise - return graph data.\nif(nodeRound){var ticketDataForRound=userNodeData.find(function(roundTickets){return roundTickets.roundId===nodeRound.lotteryId;});// if isLoading === true, there has been a node error - return graphRound\nif(!nodeRound.isLoading){return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:graphRound.totalTickets,tickets:ticketDataForRound.userTickets};}return graphRound;}return graphRound;});return mergedResponse;};export var getGraphLotteryUser=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(account){var first,skip,where,user,blankUser,response,userRes,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:first=_args.length>1&&_args[1]!==undefined?_args[1]:MAX_USER_LOTTERIES_REQUEST_SIZE;skip=_args.length>2&&_args[2]!==undefined?_args[2]:0;where=_args.length>3&&_args[3]!==undefined?_args[3]:{};blankUser={account:account,totalCake:'',totalTickets:'',rounds:[]};_context.prev=4;_context.next=7;return request(GRAPH_API_LOTTERY,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\\n          user(id: $account) {\\n            id\\n            totalTickets\\n            totalCake\\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\\n              id\\n              lottery {\\n                id\\n                endTime\\n                status\\n              }\\n              claimed\\n              totalTickets\\n            }\\n          }\\n        }\\n      \"]))),{account:account.toLowerCase(),first:first,skip:skip,where:where});case 7:response=_context.sent;userRes=response.user;// If no user returned - return blank user\nif(!userRes){user=blankUser;}else{user={account:userRes.id,totalCake:userRes.totalCake,totalTickets:userRes.totalTickets,rounds:userRes.rounds.map(function(round){var _round$lottery,_round$lottery2,_round$lottery3;return{lotteryId:round===null||round===void 0?void 0:(_round$lottery=round.lottery)===null||_round$lottery===void 0?void 0:_round$lottery.id,endTime:round===null||round===void 0?void 0:(_round$lottery2=round.lottery)===null||_round$lottery2===void 0?void 0:_round$lottery2.endTime,claimed:round===null||round===void 0?void 0:round.claimed,totalTickets:round===null||round===void 0?void 0:round.totalTickets,status:round===null||round===void 0?void 0:(_round$lottery3=round.lottery)===null||_round$lottery3===void 0?void 0:_round$lottery3.status};})};}_context.next=16;break;case 12:_context.prev=12;_context.t0=_context[\"catch\"](4);console.error(_context.t0);user=blankUser;case 16:return _context.abrupt(\"return\",user);case 17:case\"end\":return _context.stop();}}},_callee,null,[[4,12]]);}));return function getGraphLotteryUser(_x){return _ref.apply(this,arguments);};}();var getUserLotteryData=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(account,currentLotteryId){var idsForTicketsNodeCall,roundDataAndUserTickets,userRoundsNodeData,idsForLotteriesNodeCall,lotteriesNodeData,graphResponse,mergedRoundData,graphResponseWithNodeRounds;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:idsForTicketsNodeCall=getRoundIdsArray(currentLotteryId);_context2.next=3;return fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall,account);case 3:roundDataAndUserTickets=_context2.sent;userRoundsNodeData=roundDataAndUserTickets.filter(function(round){return round.userTickets.length>0;});idsForLotteriesNodeCall=userRoundsNodeData.map(function(round){return round.roundId;});_context2.next=8;return fetchMultipleLotteries(idsForLotteriesNodeCall);case 8:lotteriesNodeData=_context2.sent;_context2.next=11;return getGraphLotteryUser(account);case 11:graphResponse=_context2.sent;mergedRoundData=applyNodeDataToUserGraphResponse(userRoundsNodeData,graphResponse.rounds,lotteriesNodeData);graphResponseWithNodeRounds=_objectSpread(_objectSpread({},graphResponse),{},{rounds:mergedRoundData});return _context2.abrupt(\"return\",graphResponseWithNodeRounds);case 15:case\"end\":return _context2.stop();}}},_callee2);}));return function getUserLotteryData(_x2,_x3){return _ref2.apply(this,arguments);};}();export default getUserLotteryData;","map":{"version":3,"sources":["C:/Users/97154/swap/hami/LokiswapUI/src/state/lottery/getUserLotteryData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","fetchUserTicketsForMultipleRounds","MAX_USER_LOTTERIES_REQUEST_SIZE","applyNodeDataToUserGraphResponse","userNodeData","userGraphData","lotteryNodeData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","tickets","mergedResponse","graphRound","index","isLoading","getGraphLotteryUser","account","first","skip","where","blankUser","totalCake","rounds","toLowerCase","response","userRes","user","id","round","lottery","console","error","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","roundDataAndUserTickets","userRoundsNodeData","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\r\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\r\nimport { LotteryTicket } from 'config/constants/types'\r\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\r\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers'\r\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\r\n\r\nconst MAX_USER_LOTTERIES_REQUEST_SIZE = 100\r\n\r\n/* eslint-disable camelcase */\r\ntype UserLotteriesWhere = { lottery_in?: string[] }\r\n\r\nconst applyNodeDataToUserGraphResponse = (\r\n  userNodeData: { roundId: string; userTickets: LotteryTicket[] }[],\r\n  userGraphData: UserRound[],\r\n  lotteryNodeData: LotteryResponse[],\r\n): UserRound[] => {\r\n  //   If no graph rounds response - return node data\r\n  if (userGraphData.length === 0) {\r\n    return lotteryNodeData.map((nodeRound) => {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      return {\r\n        endTime: nodeRound.endTime,\r\n        status: nodeRound.status,\r\n        lotteryId: nodeRound.lotteryId.toString(),\r\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\r\n        tickets: ticketDataForRound.userTickets,\r\n      }\r\n    })\r\n  }\r\n\r\n  //   Else if there is a graph response - merge with node data where node data is more accurate\r\n  const mergedResponse = userGraphData.map((graphRound, index) => {\r\n    const nodeRound = lotteryNodeData[index]\r\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\r\n    if (nodeRound) {\r\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\r\n      // if isLoading === true, there has been a node error - return graphRound\r\n      if (!nodeRound.isLoading) {\r\n        return {\r\n          endTime: nodeRound.endTime,\r\n          status: nodeRound.status,\r\n          lotteryId: nodeRound.lotteryId.toString(),\r\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\r\n          totalTickets: graphRound.totalTickets,\r\n          tickets: ticketDataForRound.userTickets,\r\n        }\r\n      }\r\n      return graphRound\r\n    }\r\n    return graphRound\r\n  })\r\n  return mergedResponse\r\n}\r\n\r\nexport const getGraphLotteryUser = async (\r\n  account: string,\r\n  first = MAX_USER_LOTTERIES_REQUEST_SIZE,\r\n  skip = 0,\r\n  where: UserLotteriesWhere = {},\r\n): Promise<LotteryUserGraphEntity> => {\r\n  let user\r\n  const blankUser = {\r\n    account,\r\n    totalCake: '',\r\n    totalTickets: '',\r\n    rounds: [],\r\n  }\r\n\r\n  try {\r\n    const response = await request(\r\n      GRAPH_API_LOTTERY,\r\n      gql`\r\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\r\n          user(id: $account) {\r\n            id\r\n            totalTickets\r\n            totalCake\r\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\r\n              id\r\n              lottery {\r\n                id\r\n                endTime\r\n                status\r\n              }\r\n              claimed\r\n              totalTickets\r\n            }\r\n          }\r\n        }\r\n      `,\r\n      { account: account.toLowerCase(), first, skip, where },\r\n    )\r\n    const userRes = response.user\r\n\r\n    // If no user returned - return blank user\r\n    if (!userRes) {\r\n      user = blankUser\r\n    } else {\r\n      user = {\r\n        account: userRes.id,\r\n        totalCake: userRes.totalCake,\r\n        totalTickets: userRes.totalTickets,\r\n        rounds: userRes.rounds.map((round) => {\r\n          return {\r\n            lotteryId: round?.lottery?.id,\r\n            endTime: round?.lottery?.endTime,\r\n            claimed: round?.claimed,\r\n            totalTickets: round?.totalTickets,\r\n            status: round?.lottery?.status,\r\n          }\r\n        }),\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(error)\r\n    user = blankUser\r\n  }\r\n\r\n  return user\r\n}\r\n\r\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\r\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\r\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account)\r\n  const userRoundsNodeData = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\r\n  const idsForLotteriesNodeCall = userRoundsNodeData.map((round) => round.roundId)\r\n\r\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\r\n  const graphResponse = await getGraphLotteryUser(account)\r\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData)\r\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\r\n  return graphResponseWithNodeRounds\r\n}\r\n\r\nexport default getUserLotteryData\r\n"]},"metadata":{},"sourceType":"module"}