{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/Users/97154/swap/hami/LokiswapUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nanoid}from'@reduxjs/toolkit';import{ChainId}from'@pancakeswap/sdk';import{useCallback}from'react';import{useDispatch}from'react-redux';import useActiveWeb3React from'hooks/useActiveWeb3React';import{fetchTokenList}from'../state/lists/actions';import getTokenList from'../utils/getTokenList';import resolveENSContentHash from'../utils/ENS/resolveENSContentHash';import useWeb3Provider from'./useActiveWeb3React';function useFetchListCallback(){var _useWeb3Provider=useWeb3Provider(),library=_useWeb3Provider.library;var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var dispatch=useDispatch();var ensResolver=useCallback(function(ensName){if(chainId!==ChainId.MAINNET){throw new Error('Could not construct mainnet ENS resolver');}return resolveENSContentHash(ensName,library);},[chainId,library]);// note: prevent dispatch if using for list search or unsupported list\nreturn useCallback(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(listUrl){var sendDispatch,requestId,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:sendDispatch=_args.length>1&&_args[1]!==undefined?_args[1]:true;requestId=nanoid();if(sendDispatch){dispatch(fetchTokenList.pending({requestId:requestId,url:listUrl}));}return _context.abrupt(\"return\",getTokenList(listUrl,ensResolver).then(function(tokenList){if(sendDispatch){dispatch(fetchTokenList.fulfilled({url:listUrl,tokenList:tokenList,requestId:requestId}));}return tokenList;}).catch(function(error){console.error(\"Failed to get list at url \".concat(listUrl),error);if(sendDispatch){dispatch(fetchTokenList.rejected({url:listUrl,requestId:requestId,errorMessage:error.message}));}throw error;}));case 4:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}(),[dispatch,ensResolver]);}export default useFetchListCallback;","map":{"version":3,"sources":["C:/Users/97154/swap/hami/LokiswapUI/src/hooks/useFetchListCallback.ts"],"names":["nanoid","ChainId","useCallback","useDispatch","useActiveWeb3React","fetchTokenList","getTokenList","resolveENSContentHash","useWeb3Provider","useFetchListCallback","library","chainId","dispatch","ensResolver","ensName","MAINNET","Error","listUrl","sendDispatch","requestId","pending","url","then","tokenList","fulfilled","catch","error","console","rejected","errorMessage","message"],"mappings":"iTAAA,OAASA,MAAT,KAAuB,kBAAvB,CACA,OAASC,OAAT,KAAwB,kBAAxB,CAEA,OAASC,WAAT,KAA4B,OAA5B,CACA,OAASC,WAAT,KAA4B,aAA5B,CACA,MAAOC,CAAAA,kBAAP,KAA+B,0BAA/B,CAEA,OAASC,cAAT,KAA+B,wBAA/B,CACA,MAAOC,CAAAA,YAAP,KAAyB,uBAAzB,CACA,MAAOC,CAAAA,qBAAP,KAAkC,oCAAlC,CACA,MAAOC,CAAAA,eAAP,KAA4B,sBAA5B,CAEA,QAASC,CAAAA,oBAAT,EAAiG,CAC/F,qBAAoBD,eAAe,EAAnC,CAAQE,OAAR,kBAAQA,OAAR,CACA,wBAAoBN,kBAAkB,EAAtC,CAAQO,OAAR,qBAAQA,OAAR,CACA,GAAMC,CAAAA,QAAQ,CAAGT,WAAW,EAA5B,CAEA,GAAMU,CAAAA,WAAW,CAAGX,WAAW,CAC7B,SAACY,OAAD,CAAqB,CACnB,GAAIH,OAAO,GAAKV,OAAO,CAACc,OAAxB,CAAiC,CAC/B,KAAM,IAAIC,CAAAA,KAAJ,CAAU,0CAAV,CAAN,CACD,CACD,MAAOT,CAAAA,qBAAqB,CAACO,OAAD,CAAUJ,OAAV,CAA5B,CACD,CAN4B,CAO7B,CAACC,OAAD,CAAUD,OAAV,CAP6B,CAA/B,CAUA;AACA,MAAOR,CAAAA,WAAW,0FAChB,iBAAOe,OAAP,6JAAwBC,YAAxB,+CAAuC,IAAvC,CACQC,SADR,CACoBnB,MAAM,EAD1B,CAEE,GAAIkB,YAAJ,CAAkB,CAChBN,QAAQ,CAACP,cAAc,CAACe,OAAf,CAAuB,CAAED,SAAS,CAATA,SAAF,CAAaE,GAAG,CAAEJ,OAAlB,CAAvB,CAAD,CAAR,CACD,CAJH,gCAKSX,YAAY,CAACW,OAAD,CAAUJ,WAAV,CAAZ,CACJS,IADI,CACC,SAACC,SAAD,CAAe,CACnB,GAAIL,YAAJ,CAAkB,CAChBN,QAAQ,CAACP,cAAc,CAACmB,SAAf,CAAyB,CAAEH,GAAG,CAAEJ,OAAP,CAAgBM,SAAS,CAATA,SAAhB,CAA2BJ,SAAS,CAATA,SAA3B,CAAzB,CAAD,CAAR,CACD,CACD,MAAOI,CAAAA,SAAP,CACD,CANI,EAOJE,KAPI,CAOE,SAACC,KAAD,CAAW,CAChBC,OAAO,CAACD,KAAR,qCAA2CT,OAA3C,EAAsDS,KAAtD,EACA,GAAIR,YAAJ,CAAkB,CAChBN,QAAQ,CAACP,cAAc,CAACuB,QAAf,CAAwB,CAAEP,GAAG,CAAEJ,OAAP,CAAgBE,SAAS,CAATA,SAAhB,CAA2BU,YAAY,CAAEH,KAAK,CAACI,OAA/C,CAAxB,CAAD,CAAR,CACD,CACD,KAAMJ,CAAAA,KAAN,CACD,CAbI,CALT,wDADgB,+DAqBhB,CAACd,QAAD,CAAWC,WAAX,CArBgB,CAAlB,CAuBD,CAED,cAAeJ,CAAAA,oBAAf","sourcesContent":["import { nanoid } from '@reduxjs/toolkit'\r\nimport { ChainId } from '@pancakeswap/sdk'\r\nimport { TokenList } from '@uniswap/token-lists'\r\nimport { useCallback } from 'react'\r\nimport { useDispatch } from 'react-redux'\r\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\r\nimport { AppDispatch } from '../state'\r\nimport { fetchTokenList } from '../state/lists/actions'\r\nimport getTokenList from '../utils/getTokenList'\r\nimport resolveENSContentHash from '../utils/ENS/resolveENSContentHash'\r\nimport useWeb3Provider from './useActiveWeb3React'\r\n\r\nfunction useFetchListCallback(): (listUrl: string, sendDispatch?: boolean) => Promise<TokenList> {\r\n  const { library } = useWeb3Provider()\r\n  const { chainId } = useActiveWeb3React()\r\n  const dispatch = useDispatch<AppDispatch>()\r\n\r\n  const ensResolver = useCallback(\r\n    (ensName: string) => {\r\n      if (chainId !== ChainId.MAINNET) {\r\n        throw new Error('Could not construct mainnet ENS resolver')\r\n      }\r\n      return resolveENSContentHash(ensName, library)\r\n    },\r\n    [chainId, library],\r\n  )\r\n\r\n  // note: prevent dispatch if using for list search or unsupported list\r\n  return useCallback(\r\n    async (listUrl: string, sendDispatch = true) => {\r\n      const requestId = nanoid()\r\n      if (sendDispatch) {\r\n        dispatch(fetchTokenList.pending({ requestId, url: listUrl }))\r\n      }\r\n      return getTokenList(listUrl, ensResolver)\r\n        .then((tokenList) => {\r\n          if (sendDispatch) {\r\n            dispatch(fetchTokenList.fulfilled({ url: listUrl, tokenList, requestId }))\r\n          }\r\n          return tokenList\r\n        })\r\n        .catch((error) => {\r\n          console.error(`Failed to get list at url ${listUrl}`, error)\r\n          if (sendDispatch) {\r\n            dispatch(fetchTokenList.rejected({ url: listUrl, requestId, errorMessage: error.message }))\r\n          }\r\n          throw error\r\n        })\r\n    },\r\n    [dispatch, ensResolver],\r\n  )\r\n}\r\n\r\nexport default useFetchListCallback\r\n"]},"metadata":{},"sourceType":"module"}